<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>Toyscape</title>
<style>
/* ============================================
   RESET & BASE
   ============================================ */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: fixed;
  top: 0; left: 0;
  touch-action: none;
  background: #1a1a1a;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
}

/* ============================================
   VIEWPORT CONTAINER
   ============================================ */
#viewport {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  background: #1a1a1a;
  transition: background 1s ease;
}

#viewport.night {
  background: #0a0a0a;
}

/* ============================================
   GRID WRAPPER ‚Äî transformed for pan/zoom
   ============================================ */
#grid-wrapper {
  position: absolute;
  top: 0; left: 0;
  transform-origin: 0 0;
  will-change: transform;
}

/* ============================================
   TILE GRID
   ============================================ */
#tile-grid {
  display: grid;
  position: relative;
}

.tile-cell {
  position: relative;
  overflow: hidden;
  cursor: pointer;
}

/* Edit mode: show grid lines on ALL cells */
#viewport.edit-mode .tile-cell {
  border: 1px solid rgba(200,200,200,0.5);
}

#viewport.edit-mode .tile-cell.empty {
  background: #f5f5f5;
  border-color: #ddd;
}

/* Play mode: no grid lines */
#viewport.play-mode .tile-cell {
  border: none;
}

/* Play mode: fill empty cells with grass */
#viewport.play-mode .tile-cell.empty {
  background-image: url('assets/ground_grass.png');
  background-size: cover;
  background-position: center;
  border: none;
}

/* Night mode dimming for grass cells in play mode */
#viewport.night.play-mode .tile-cell.empty {
  filter: brightness(0.3);
}

.tile-cell .tile-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  transition: transform 0.2s ease;
  pointer-events: none;
}

/* Night mode dimming for placed tiles */
#viewport.night .tile-cell .tile-img {
  filter: brightness(0.4);
}

/* Hospital tile glow in night */
#viewport.night .tile-cell[data-type="building_hospital"] .tile-img {
  filter: brightness(0.5) saturate(0.7);
}

/* Delete flash */
.tile-cell.delete-flash {
  animation: deleteFlash 0.3s ease;
}

@keyframes deleteFlash {
  0% { background: transparent; }
  30% { background: rgba(255,0,0,0.4); }
  100% { background: transparent; }
}

/* ============================================
   ROTATE OVERLAY
   ============================================ */
.rotate-overlay {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: rgba(0,0,0,0.75);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  color: #fff;
  cursor: pointer;
  z-index: 200;
  box-shadow: 0 2px 10px rgba(0,0,0,0.4);
  transition: transform 0.15s ease;
  pointer-events: auto;
  touch-action: manipulation;
}

.rotate-overlay:active {
  transform: translate(-50%, -50%) scale(0.9);
}

/* ============================================
   DRAG GHOST
   ============================================ */
#drag-ghost {
  position: fixed;
  pointer-events: none;
  z-index: 1000;
  opacity: 0.8;
  display: none;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  border-radius: 6px;
  overflow: hidden;
}

#drag-ghost img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* ============================================
   TILE PALETTE (edit mode only)
   ============================================ */
#tile-palette {
  position: fixed;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  padding: 10px 16px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-radius: 16px;
  z-index: 500;
  transition: opacity 0.25s ease, transform 0.25s ease;
  overflow-x: auto;
  max-width: 90vw;
  -webkit-overflow-scrolling: touch;
}

#tile-palette.hidden {
  opacity: 0;
  transform: translateX(-50%) translateY(20px);
  pointer-events: none;
}

.palette-tile {
  width: 52px;
  height: 52px;
  min-width: 52px;
  border-radius: 8px;
  overflow: hidden;
  cursor: grab;
  border: 2px solid rgba(255,255,255,0.2);
  transition: border-color 0.15s, transform 0.15s;
  background: #333;
  touch-action: none;
}

.palette-tile:active {
  transform: scale(0.92);
}

.palette-tile img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  pointer-events: none;
}

/* ============================================
   FLOATING UI BUTTONS
   ============================================ */
.ui-btn {
  position: fixed;
  width: 46px;
  height: 46px;
  border-radius: 12px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255,255,255,0.15);
  color: #fff;
  font-size: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 500;
  transition: background 0.2s, transform 0.15s;
  line-height: 1;
  touch-action: manipulation;
}

.ui-btn:active {
  transform: scale(0.9);
}

/* Mode toggle ‚Äî top right */
#mode-btn {
  top: 16px;
  right: 16px;
}

/* Lock button ‚Äî top left (play mode only) */
#lock-btn {
  top: 16px;
  left: 16px;
  transition: background 0.2s, transform 0.15s, opacity 0.25s;
}

#lock-btn.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Clear button ‚Äî next to mode toggle */
#clear-btn {
  top: 16px;
  right: 72px;
  font-size: 20px;
}

#clear-btn.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Day/night toggle */
#daynight-btn {
  bottom: 16px;
  right: 16px;
  width: 46px;
  height: 46px;
  border-radius: 50%;
  background: rgba(255,213,79,0.9);
  border: 2px solid rgba(255,255,255,0.4);
  transition: background 0.5s, border-color 0.5s, box-shadow 0.5s;
}

#daynight-btn.night {
  background: rgba(26,35,126,0.9);
  border-color: rgba(200,200,255,0.3);
  box-shadow: 0 0 12px rgba(100,100,200,0.3);
}

.sun-icon, .moon-icon {
  position: absolute;
  transition: opacity 0.4s, transform 0.4s;
}

.sun-icon {
  width: 20px;
  height: 20px;
  background: #ff8f00;
  border-radius: 50%;
  box-shadow: 0 0 8px rgba(255,143,0,0.5);
}

.moon-icon {
  width: 18px;
  height: 18px;
  background: #e8eaf6;
  border-radius: 50%;
  box-shadow: inset -4px -2px 0 0 #1a237e;
  opacity: 0;
  transform: rotate(-40deg) scale(0.6);
}

#daynight-btn.night .sun-icon {
  opacity: 0;
  transform: rotate(90deg) scale(0.5);
}

#daynight-btn.night .moon-icon {
  opacity: 1;
  transform: rotate(0deg) scale(1);
}

/* ============================================
   PLAY MODE: HOSPITAL SIREN FLASH OVERLAY
   ============================================ */
.siren-flash {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,0,0,0);
  pointer-events: none;
  z-index: 10;
  transition: background 0.12s;
}

.siren-flash.on {
  background: rgba(255,0,0,0.35);
}
</style>
</head>
<body>

<div id="viewport" class="edit-mode">
  <div id="grid-wrapper">
    <div id="tile-grid"></div>
  </div>
</div>

<!-- Drag ghost element -->
<div id="drag-ghost"><img src="" alt=""></div>

<!-- Tile Palette -->
<div id="tile-palette">
  <div class="palette-tile" data-tile="ground_grass">
    <img src="assets/ground_grass.png" alt="Grass" draggable="false">
  </div>
  <div class="palette-tile" data-tile="road_vertical">
    <img src="assets/road_vertical.png" alt="Road" draggable="false">
  </div>
  <div class="palette-tile" data-tile="road_curved">
    <img src="assets/road_curved.png" alt="Curve" draggable="false">
  </div>
  <div class="palette-tile" data-tile="road_crossroad">
    <img src="assets/road_crossroad.png" alt="Crossroad" draggable="false">
  </div>
  <div class="palette-tile" data-tile="building_hospital">
    <img src="assets/building_hospital.png" alt="Hospital" draggable="false">
  </div>
</div>

<!-- Floating UI -->
<button class="ui-btn" id="mode-btn" title="Toggle Mode">‚úèÔ∏è</button>
<button class="ui-btn hidden" id="lock-btn" title="Touch Lock">üîì</button>
<button class="ui-btn" id="clear-btn" title="Clear Grid">üóëÔ∏è</button>
<div class="ui-btn" id="daynight-btn">
  <div class="sun-icon"></div>
  <div class="moon-icon"></div>
</div>

<script>
// =============================================
// CONFIGURATION
// =============================================
var GRID_COLS = 10;
var GRID_ROWS = 14;
var TILE_SIZE = 100; // px per tile at scale 1

// =============================================
// STATE
// =============================================
var gridData = []; // [{type: string|null, rotation: 0|90|180|270}]
var currentMode = 'edit'; // 'edit' | 'play'
var isNight = false;
var isLocked = true; // play mode touch lock
var selectedCell = -1; // cell index with rotate overlay showing

// Pan / Zoom state
var panX = 0, panY = 0, scale = 1;
var MIN_SCALE = 0.3, MAX_SCALE = 3;

// Drag state
var dragTileType = null;
var dragActive = false;
var dragStartX = 0, dragStartY = 0;

// =============================================
// DOM REFS
// =============================================
var viewport = document.getElementById('viewport');
var gridWrapper = document.getElementById('grid-wrapper');
var tileGrid = document.getElementById('tile-grid');
var palette = document.getElementById('tile-palette');
var dragGhost = document.getElementById('drag-ghost');
var ghostImg = dragGhost.querySelector('img');
var modeBtn = document.getElementById('mode-btn');
var lockBtn = document.getElementById('lock-btn');
var clearBtn = document.getElementById('clear-btn');
var dnBtn = document.getElementById('daynight-btn');

// =============================================
// WEB AUDIO API ‚Äî All sounds synthesized (preserved from original)
// =============================================
var audioCtx = null;

function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

function playSiren(duration) {
  duration = duration || 2.5;
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(400, t);
  for (var i = 0; i < 6; i++) {
    var segEnd = t + (i + 1) * (duration / 6);
    osc.frequency.linearRampToValueAtTime(i % 2 === 0 ? 800 : 400, segEnd);
  }
  gain.gain.setValueAtTime(0.18, t);
  gain.gain.linearRampToValueAtTime(0, t + duration);
  osc.connect(gain).connect(ctx.destination);
  osc.start(t);
  osc.stop(t + duration);
}

function playRotor(duration) {
  duration = duration || 3;
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var lfo = ctx.createOscillator();
  var lfoGain = ctx.createGain();
  var master = ctx.createGain();
  osc.type = 'sawtooth';
  osc.frequency.value = 55;
  lfo.type = 'square';
  lfo.frequency.setValueAtTime(18, t);
  lfo.frequency.linearRampToValueAtTime(26, t + duration * 0.4);
  lfo.frequency.linearRampToValueAtTime(20, t + duration);
  lfoGain.gain.value = 0.15;
  master.gain.setValueAtTime(0.15, t);
  master.gain.linearRampToValueAtTime(0, t + duration);
  lfo.connect(lfoGain);
  lfoGain.connect(master.gain);
  osc.connect(master).connect(ctx.destination);
  osc.start(t); lfo.start(t);
  osc.stop(t + duration); lfo.stop(t + duration);
}

function playBarrier() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var buf = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
  var ch = buf.getChannelData(0);
  for (var i = 0; i < ch.length; i++) ch[i] = (Math.random() * 2 - 1) * 0.3;
  var src = ctx.createBufferSource();
  src.buffer = buf;
  var bp = ctx.createBiquadFilter();
  bp.type = 'bandpass'; bp.frequency.value = 1200; bp.Q.value = 5;
  var ng = ctx.createGain();
  ng.gain.setValueAtTime(0.1, t);
  ng.gain.linearRampToValueAtTime(0, t + 0.5);
  src.connect(bp).connect(ng).connect(ctx.destination);
  src.start(t); src.stop(t + 0.5);
  var beep = ctx.createOscillator();
  var bg = ctx.createGain();
  beep.type = 'sine'; beep.frequency.value = 880;
  bg.gain.setValueAtTime(0, t);
  bg.gain.setValueAtTime(0.12, t + 0.35);
  bg.gain.linearRampToValueAtTime(0, t + 0.5);
  beep.connect(bg).connect(ctx.destination);
  beep.start(t + 0.35); beep.stop(t + 0.5);
}

function playClick() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.type = 'square';
  osc.frequency.setValueAtTime(1500, t);
  osc.frequency.exponentialRampToValueAtTime(200, t + 0.03);
  gain.gain.setValueAtTime(0.15, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
  osc.connect(gain).connect(ctx.destination);
  osc.start(t); osc.stop(t + 0.06);
}

function playParkingBeep() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var total = 1.8;
  var count = 10;
  for (var i = 0; i < count; i++) {
    var p = i / count;
    var when = t + p * p * total;
    var osc = ctx.createOscillator();
    var g = ctx.createGain();
    osc.type = 'sine'; osc.frequency.value = 1000;
    g.gain.setValueAtTime(0.12, when);
    g.gain.linearRampToValueAtTime(0, when + 0.05);
    osc.connect(g).connect(ctx.destination);
    osc.start(when); osc.stop(when + 0.05);
  }
  return total;
}

function playTicket() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var lfo = ctx.createOscillator();
  var lg = ctx.createGain();
  var mg = ctx.createGain();
  osc.type = 'square'; osc.frequency.value = 300;
  lfo.type = 'square'; lfo.frequency.value = 40;
  lg.gain.value = 200;
  mg.gain.setValueAtTime(0.08, t);
  mg.gain.linearRampToValueAtTime(0, t + 0.35);
  lfo.connect(lg); lg.connect(osc.frequency);
  osc.connect(mg).connect(ctx.destination);
  osc.start(t); lfo.start(t);
  osc.stop(t + 0.35); lfo.stop(t + 0.35);
}

function playPlaceTile() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(600, t);
  osc.frequency.exponentialRampToValueAtTime(900, t + 0.08);
  gain.gain.setValueAtTime(0.1, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  osc.connect(gain).connect(ctx.destination);
  osc.start(t); osc.stop(t + 0.12);
}

function playDeleteTile() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(500, t);
  osc.frequency.exponentialRampToValueAtTime(200, t + 0.15);
  gain.gain.setValueAtTime(0.1, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
  osc.connect(gain).connect(ctx.destination);
  osc.start(t); osc.stop(t + 0.2);
}

function playRotateSound() {
  var ctx = ensureAudio();
  var t = ctx.currentTime;
  var osc = ctx.createOscillator();
  var gain = ctx.createGain();
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(400, t);
  osc.frequency.linearRampToValueAtTime(700, t + 0.1);
  gain.gain.setValueAtTime(0.08, t);
  gain.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  osc.connect(gain).connect(ctx.destination);
  osc.start(t); osc.stop(t + 0.12);
}

// =============================================
// GRID INITIALIZATION
// =============================================
function initGrid() {
  // Initialize grid data array
  gridData = [];
  for (var i = 0; i < GRID_COLS * GRID_ROWS; i++) {
    gridData.push({ type: null, rotation: 0 });
  }

  // Try to load from localStorage
  loadGridState();

  // Build DOM
  buildGridDOM();

  // Center grid in viewport
  var vw = window.innerWidth;
  var vh = window.innerHeight;
  var gw = GRID_COLS * TILE_SIZE;
  var gh = GRID_ROWS * TILE_SIZE;

  // Fit grid to viewport with some padding
  var scaleX = (vw * 0.85) / gw;
  var scaleY = (vh * 0.85) / gh;
  scale = Math.min(scaleX, scaleY, 1.5);
  scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));

  panX = (vw - gw * scale) / 2;
  panY = (vh - gh * scale) / 2;

  applyTransform();
}

function buildGridDOM() {
  tileGrid.innerHTML = '';
  tileGrid.style.gridTemplateColumns = 'repeat(' + GRID_COLS + ', ' + TILE_SIZE + 'px)';
  tileGrid.style.gridTemplateRows = 'repeat(' + GRID_ROWS + ', ' + TILE_SIZE + 'px)';
  tileGrid.style.width = (GRID_COLS * TILE_SIZE) + 'px';
  tileGrid.style.height = (GRID_ROWS * TILE_SIZE) + 'px';

  for (var i = 0; i < GRID_COLS * GRID_ROWS; i++) {
    var cell = document.createElement('div');
    cell.className = 'tile-cell';
    cell.dataset.idx = i;

    var data = gridData[i];
    if (data.type) {
      cell.classList.remove('empty');
      cell.dataset.type = data.type;
      var img = document.createElement('img');
      img.className = 'tile-img';
      img.src = 'assets/' + data.type + '.png';
      img.draggable = false;
      img.style.transform = 'rotate(' + data.rotation + 'deg)';
      cell.appendChild(img);
    } else {
      cell.classList.add('empty');
    }

    cell.style.width = TILE_SIZE + 'px';
    cell.style.height = TILE_SIZE + 'px';

    tileGrid.appendChild(cell);
  }
}

function applyTransform() {
  gridWrapper.style.transform = 'translate(' + panX + 'px, ' + panY + 'px) scale(' + scale + ')';
}

// =============================================
// TILE OPERATIONS
// =============================================
function placeTile(cellIdx, tileType, rotation) {
  if (cellIdx < 0 || cellIdx >= gridData.length) return;
  rotation = rotation || 0;
  gridData[cellIdx] = { type: tileType, rotation: rotation };

  var cell = tileGrid.children[cellIdx];
  cell.classList.remove('empty');
  cell.dataset.type = tileType;

  // Remove old content
  while (cell.firstChild) cell.removeChild(cell.firstChild);

  var img = document.createElement('img');
  img.className = 'tile-img';
  img.src = 'assets/' + tileType + '.png';
  img.draggable = false;
  img.style.transform = 'rotate(' + rotation + 'deg)';
  cell.appendChild(img);

  playPlaceTile();
  saveGridState();
}

function removeTile(cellIdx) {
  if (cellIdx < 0 || cellIdx >= gridData.length) return;
  gridData[cellIdx] = { type: null, rotation: 0 };

  var cell = tileGrid.children[cellIdx];
  cell.classList.add('empty');
  delete cell.dataset.type;

  while (cell.firstChild) cell.removeChild(cell.firstChild);

  cell.classList.add('delete-flash');
  setTimeout(function() { cell.classList.remove('delete-flash'); }, 300);

  playDeleteTile();
  saveGridState();
}

function rotateTile(cellIdx) {
  if (cellIdx < 0 || cellIdx >= gridData.length) return;
  var d = gridData[cellIdx];
  if (!d.type) return;

  d.rotation = (d.rotation + 90) % 360;

  var cell = tileGrid.children[cellIdx];
  var img = cell.querySelector('.tile-img');
  if (img) {
    img.style.transform = 'rotate(' + d.rotation + 'deg)';
  }

  playRotateSound();
  saveGridState();
}

// =============================================
// ROTATE OVERLAY
// =============================================
function showRotateOverlay(cellIdx) {
  dismissRotateOverlay();
  if (!gridData[cellIdx].type) return;
  selectedCell = cellIdx;

  var cell = tileGrid.children[cellIdx];
  var overlay = document.createElement('div');
  overlay.className = 'rotate-overlay';
  overlay.id = 'rotate-overlay';
  overlay.textContent = '‚Üª';

  overlay.addEventListener('touchstart', function(e) {
    e.stopPropagation();
    e.preventDefault();
    rotateTile(cellIdx);
  }, { passive: false });

  overlay.addEventListener('click', function(e) {
    e.stopPropagation();
    rotateTile(cellIdx);
  });

  cell.appendChild(overlay);
}

function dismissRotateOverlay() {
  var existing = document.getElementById('rotate-overlay');
  if (existing) existing.parentNode.removeChild(existing);
  selectedCell = -1;
}

// =============================================
// PERSISTENCE ‚Äî localStorage
// =============================================
var STORAGE_KEY = 'toyscape_grid_v1';

function saveGridState() {
  try {
    var compact = [];
    for (var i = 0; i < gridData.length; i++) {
      var d = gridData[i];
      if (d.type) {
        compact.push({ i: i, t: d.type, r: d.rotation });
      }
    }
    var state = {
      cols: GRID_COLS,
      rows: GRID_ROWS,
      tiles: compact
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    // localStorage may be unavailable
  }
}

function loadGridState() {
  try {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    var state = JSON.parse(raw);
    if (state.cols !== GRID_COLS || state.rows !== GRID_ROWS) return; // grid size changed

    for (var j = 0; j < state.tiles.length; j++) {
      var t = state.tiles[j];
      if (t.i >= 0 && t.i < gridData.length) {
        gridData[t.i] = { type: t.t, rotation: t.r || 0 };
      }
    }
  } catch (e) {
    // ignore parse errors
  }
}

function clearGrid() {
  for (var i = 0; i < gridData.length; i++) {
    gridData[i] = { type: null, rotation: 0 };
  }
  buildGridDOM();
  saveGridState();
}

// =============================================
// MODE SWITCHING
// =============================================
function setMode(mode) {
  currentMode = mode;
  viewport.classList.remove('edit-mode', 'play-mode');
  viewport.classList.add(mode + '-mode');

  if (mode === 'edit') {
    modeBtn.textContent = '‚úèÔ∏è';
    palette.classList.remove('hidden');
    lockBtn.classList.add('hidden');
    clearBtn.classList.remove('hidden');
    dismissRotateOverlay();
  } else {
    modeBtn.textContent = '‚ñ∂Ô∏è';
    palette.classList.add('hidden');
    lockBtn.classList.remove('hidden');
    clearBtn.classList.add('hidden');
    dismissRotateOverlay();
    // Reset lock to locked on entering play mode
    isLocked = true;
    lockBtn.textContent = 'üîí';
  }
}

// =============================================
// PAN & ZOOM
// =============================================
var pointers = {}; // active pointers by ID
var lastPinchDist = 0;
var lastPinchCenterX = 0, lastPinchCenterY = 0;
var isPanning = false;
var panStartX = 0, panStartY = 0;
var panStartPanX = 0, panStartPanY = 0;

// Mouse wheel zoom
viewport.addEventListener('wheel', function(e) {
  e.preventDefault();
  var rect = viewport.getBoundingClientRect();
  var mx = e.clientX - rect.left;
  var my = e.clientY - rect.top;

  var zoomFactor = e.deltaY < 0 ? 1.08 : 0.92;
  var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));

  // Zoom toward cursor position
  panX = mx - (mx - panX) * (newScale / scale);
  panY = my - (my - panY) * (newScale / scale);
  scale = newScale;

  applyTransform();
}, { passive: false });

// Pointer tracking for touch pan/zoom
function getPointerArray() {
  var arr = [];
  for (var id in pointers) arr.push(pointers[id]);
  return arr;
}

function getPinchData(arr) {
  var dx = arr[1].x - arr[0].x;
  var dy = arr[1].y - arr[0].y;
  return {
    dist: Math.sqrt(dx * dx + dy * dy),
    cx: (arr[0].x + arr[1].x) / 2,
    cy: (arr[0].y + arr[1].y) / 2
  };
}

// =============================================
// TOUCH HANDLING ‚Äî complex multi-purpose
// =============================================
var longPressTimer = null;
var longPressCellIdx = -1;
var touchStartTime = 0;
var touchMoved = false;
var singleTouchStartX = 0, singleTouchStartY = 0;

// Prevent default touch behavior, but allow it on UI buttons so click events fire
function shouldPreventTouch(e) {
  return !e.target.closest('.ui-btn') && !e.target.closest('#tile-palette') && !e.target.closest('.rotate-overlay');
}
document.addEventListener('touchstart', function(e) { if (shouldPreventTouch(e)) e.preventDefault(); }, { passive: false });
document.addEventListener('touchmove', function(e) { if (shouldPreventTouch(e)) e.preventDefault(); }, { passive: false });
document.addEventListener('touchend', function(e) { if (shouldPreventTouch(e)) e.preventDefault(); }, { passive: false });
document.addEventListener('gesturestart', function(e) { e.preventDefault(); }, { passive: false });
document.addEventListener('gesturechange', function(e) { e.preventDefault(); }, { passive: false });

// --- POINTER DOWN ---
viewport.addEventListener('pointerdown', function(e) {
  // Don't track pointers on UI buttons
  if (e.target.closest('.ui-btn') || e.target.closest('#tile-palette') || e.target.closest('.rotate-overlay')) return;

  pointers[e.pointerId] = { x: e.clientX, y: e.clientY };
  var pArr = getPointerArray();

  if (pArr.length === 2) {
    // Start pinch
    cancelLongPress();
    cancelDrag();
    var pd = getPinchData(pArr);
    lastPinchDist = pd.dist;
    lastPinchCenterX = pd.cx;
    lastPinchCenterY = pd.cy;
    isPanning = false;
    return;
  }

  if (pArr.length === 1) {
    touchStartTime = Date.now();
    touchMoved = false;
    singleTouchStartX = e.clientX;
    singleTouchStartY = e.clientY;

    // Check if touch is on a tile cell
    var cellIdx = getCellAtPointer(e.clientX, e.clientY);

    if (currentMode === 'edit' && cellIdx >= 0 && gridData[cellIdx].type) {
      // Start long-press timer for delete
      longPressCellIdx = cellIdx;
      longPressTimer = setTimeout(function() {
        if (longPressCellIdx >= 0) {
          removeTile(longPressCellIdx);
          longPressCellIdx = -1;
        }
      }, 500);
    }
  }
}, { passive: false });

// --- POINTER MOVE ---
viewport.addEventListener('pointermove', function(e) {
  if (!pointers[e.pointerId]) return;

  var prevX = pointers[e.pointerId].x;
  var prevY = pointers[e.pointerId].y;
  pointers[e.pointerId] = { x: e.clientX, y: e.clientY };

  var pArr = getPointerArray();

  // Detect movement to cancel long-press / flag as moved
  var dx = e.clientX - singleTouchStartX;
  var dy = e.clientY - singleTouchStartY;
  if (Math.abs(dx) > 8 || Math.abs(dy) > 8) {
    touchMoved = true;
    cancelLongPress();
  }

  if (pArr.length >= 2) {
    // Pinch zoom + pan
    var pd = getPinchData(pArr);

    // Zoom
    var zoomRatio = pd.dist / lastPinchDist;
    var newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomRatio));

    // Pan during pinch (move with the center of the two fingers)
    var dCx = pd.cx - lastPinchCenterX;
    var dCy = pd.cy - lastPinchCenterY;

    // Zoom toward pinch center + translate by finger movement
    panX = panX + dCx - (lastPinchCenterX - panX) * (newScale / scale - 1);
    panY = panY + dCy - (lastPinchCenterY - panY) * (newScale / scale - 1);
    scale = newScale;

    lastPinchDist = pd.dist;
    lastPinchCenterX = pd.cx;
    lastPinchCenterY = pd.cy;

    applyTransform();
    return;
  }

  // Single pointer ‚Äî drag ghost or pan (mouse drag on empty)
  if (dragActive) {
    updateDragGhost(e.clientX, e.clientY);
    return;
  }

  // Mouse: single-click-drag on empty space = pan
  if (e.pointerType === 'mouse' && touchMoved && !dragActive) {
    panX += e.clientX - prevX;
    panY += e.clientY - prevY;
    applyTransform();
  }
}, { passive: false });

// --- POINTER UP ---
viewport.addEventListener('pointerup', function(e) {
  if (!pointers[e.pointerId]) return;
  delete pointers[e.pointerId];

  cancelLongPress();

  // Handle drag drop
  if (dragActive) {
    finishDrag(e.clientX, e.clientY);
    return;
  }

  // Single tap (not moved, short duration)
  var elapsed = Date.now() - touchStartTime;
  if (!touchMoved && elapsed < 400) {
    handleTap(e.clientX, e.clientY);
  }
}, { passive: false });

viewport.addEventListener('pointercancel', function(e) {
  delete pointers[e.pointerId];
  cancelLongPress();
  cancelDrag();
}, { passive: false });

// Mouse pan via middle-click or right-click drag (alternative)
viewport.addEventListener('contextmenu', function(e) { e.preventDefault(); });

// =============================================
// CELL LOOKUP ‚Äî convert screen coords to grid cell
// =============================================
function getCellAtPointer(clientX, clientY) {
  // Convert screen coords to grid coords
  var gx = (clientX - panX) / scale;
  var gy = (clientY - panY) / scale;

  var col = Math.floor(gx / TILE_SIZE);
  var row = Math.floor(gy / TILE_SIZE);

  if (col < 0 || col >= GRID_COLS || row < 0 || row >= GRID_ROWS) return -1;
  return row * GRID_COLS + col;
}

// =============================================
// TAP HANDLING
// =============================================
function handleTap(clientX, clientY) {
  var cellIdx = getCellAtPointer(clientX, clientY);

  if (currentMode === 'edit') {
    // Dismiss rotate overlay if tapping elsewhere
    if (selectedCell >= 0 && cellIdx !== selectedCell) {
      dismissRotateOverlay();
      return;
    }
    // Show rotate overlay on placed tile
    if (cellIdx >= 0 && gridData[cellIdx].type && selectedCell !== cellIdx) {
      showRotateOverlay(cellIdx);
      return;
    }
    dismissRotateOverlay();
  }

  if (currentMode === 'play') {
    // Locked = no interactions
    if (isLocked) return;

    // Trigger sounds based on tile type
    if (cellIdx >= 0) {
      var tileType = gridData[cellIdx].type;
      triggerTileSound(cellIdx, tileType);
    }
  }
}

// =============================================
// PLAY MODE ‚Äî TILE SOUNDS
// =============================================
var sirenActive = false;

function triggerTileSound(cellIdx, tileType) {
  if (!tileType) return;

  var cell = tileGrid.children[cellIdx];

  if (tileType === 'building_hospital') {
    if (sirenActive) return;
    sirenActive = true;
    playSiren(2.5);

    // Flash effect
    var flash = cell.querySelector('.siren-flash');
    if (!flash) {
      flash = document.createElement('div');
      flash.className = 'siren-flash';
      cell.appendChild(flash);
    }
    var n = 0;
    var iv = setInterval(function() {
      flash.classList.toggle('on');
      n++;
      if (n >= 10) {
        clearInterval(iv);
        flash.classList.remove('on');
        sirenActive = false;
      }
    }, 250);
  }

  if (tileType === 'road_crossroad') {
    // Traffic light click
    playClick();
    // Brief visual pulse
    cell.style.outline = '3px solid rgba(255,214,0,0.6)';
    setTimeout(function() { cell.style.outline = ''; }, 300);
  }

  if (tileType === 'road_vertical' || tileType === 'road_curved') {
    // Barrier / parking sound
    playBarrier();
  }

  if (tileType === 'ground_grass') {
    // Soft ambient click
    playClick();
  }
}

// =============================================
// DRAG & DROP ‚Äî from palette onto grid
// =============================================
var DRAG_THRESHOLD = 10;
var ghostSize = 80;

// Palette tile drag (touch)
palette.addEventListener('pointerdown', function(e) {
  var paletteTile = e.target.closest('.palette-tile');
  if (!paletteTile) return;
  e.stopPropagation();
  e.preventDefault();

  dragTileType = paletteTile.dataset.tile;
  dragStartX = e.clientX;
  dragStartY = e.clientY;

  // Start drag immediately
  startDrag(e.clientX, e.clientY);

  // Track this pointer globally for drag
  function onMove(ev) {
    if (ev.pointerId !== e.pointerId) return;
    updateDragGhost(ev.clientX, ev.clientY);
  }
  function onUp(ev) {
    if (ev.pointerId !== e.pointerId) return;
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
    document.removeEventListener('pointercancel', onUp);
    finishDrag(ev.clientX, ev.clientY);
  }
  document.addEventListener('pointermove', onMove, { passive: false });
  document.addEventListener('pointerup', onUp, { passive: false });
  document.addEventListener('pointercancel', onUp, { passive: false });
}, { passive: false });

function startDrag(clientX, clientY) {
  dragActive = true;
  ghostImg.src = 'assets/' + dragTileType + '.png';

  // Size ghost relative to current tile scale
  ghostSize = Math.max(60, Math.min(120, TILE_SIZE * scale));
  dragGhost.style.width = ghostSize + 'px';
  dragGhost.style.height = ghostSize + 'px';
  dragGhost.style.display = 'block';

  updateDragGhost(clientX, clientY);
}

function updateDragGhost(clientX, clientY) {
  dragGhost.style.left = (clientX - ghostSize / 2) + 'px';
  dragGhost.style.top = (clientY - ghostSize / 2) + 'px';

  // Highlight target cell
  clearCellHighlights();
  var cellIdx = getCellAtPointer(clientX, clientY);
  if (cellIdx >= 0) {
    tileGrid.children[cellIdx].style.outline = '3px solid rgba(76,175,80,0.7)';
  }
}

function finishDrag(clientX, clientY) {
  if (!dragActive) return;
  dragActive = false;
  dragGhost.style.display = 'none';
  clearCellHighlights();

  var cellIdx = getCellAtPointer(clientX, clientY);
  if (cellIdx >= 0 && dragTileType) {
    placeTile(cellIdx, dragTileType, 0);
  }

  dragTileType = null;
}

function cancelDrag() {
  dragActive = false;
  dragGhost.style.display = 'none';
  clearCellHighlights();
  dragTileType = null;
}

function clearCellHighlights() {
  var cells = tileGrid.children;
  for (var i = 0; i < cells.length; i++) {
    cells[i].style.outline = '';
  }
}

// =============================================
// LONG PRESS HELPERS
// =============================================
function cancelLongPress() {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  longPressCellIdx = -1;
}

// =============================================
// UI BUTTON HANDLERS
// =============================================

// Mode toggle
modeBtn.addEventListener('pointerdown', function(e) { e.stopPropagation(); }, { passive: false });
modeBtn.addEventListener('click', function(e) {
  e.stopPropagation();
  playClick();
  if (currentMode === 'edit') {
    setMode('play');
  } else {
    setMode('edit');
  }
});

// Lock toggle
lockBtn.addEventListener('pointerdown', function(e) { e.stopPropagation(); }, { passive: false });
lockBtn.addEventListener('click', function(e) {
  e.stopPropagation();
  playClick();
  isLocked = !isLocked;
  lockBtn.textContent = isLocked ? 'üîí' : 'üîì';
});

// Clear grid
clearBtn.addEventListener('pointerdown', function(e) { e.stopPropagation(); }, { passive: false });
clearBtn.addEventListener('click', function(e) {
  e.stopPropagation();
  if (confirm('Alle Tiles l√∂schen?')) {
    clearGrid();
    playDeleteTile();
  }
});

// Day/Night
dnBtn.addEventListener('pointerdown', function(e) { e.stopPropagation(); }, { passive: false });
dnBtn.addEventListener('click', function(e) {
  e.stopPropagation();
  playClick();
  isNight = !isNight;
  viewport.classList.toggle('night', isNight);
  dnBtn.classList.toggle('night', isNight);
});

// =============================================
// INIT
// =============================================
initGrid();
setMode('edit');

// Hide lock button initially (edit mode)
lockBtn.classList.add('hidden');
</script>
</body>
</html>
